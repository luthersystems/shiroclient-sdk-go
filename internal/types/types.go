package types

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"

	//nolint:staticcheck // Deprecated package "github.com/golang/protobuf/jsonpb" used for backwards compatibility
	"github.com/golang/protobuf/jsonpb"
	"github.com/google/uuid"
	"github.com/sirupsen/logrus"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/runtime/protoiface"
)

// ShiroClient is an abstraction for a connection to a
// blockchain-based smart contract execution engine. Currently, the
// "phylum" code must be written in a LISP dialect known as Elps.
type ShiroClient interface {
	// Seed re-opens the ShiroClient, specifying the phylum version to
	// target.
	Seed(ctx context.Context, version string, config ...Config) error

	// ShiroPhylum returns a non-empty string which should act as an
	// indentifier indicating the deployed phylum code being executed by
	// the shiro server.
	ShiroPhylum(ctx context.Context, config ...Config) (string, error)

	// Init initializes the chaincode given a string containing
	// base64-encoded phylum code.  The phylum code should be deployed
	// with the identifier returned by method ShiroPhylum().
	Init(ctx context.Context, phylum string, config ...Config) error

	// Call executes method with the given parameters and commits the
	// results.  The method shuold be executed by the phylum code
	// matching the identifier returned by method ShiroPhylum().
	//
	// Caller may specify transient data that is accessible to the
	// chaincode but not comitted on to the blockchain.
	Call(ctx context.Context, method string, config ...Config) (ShiroResponse, error)

	// QueryInfo returns the blockchain height.
	QueryInfo(ctx context.Context, config ...Config) (uint64, error)

	// QueryBlock returns summary information about the block given by
	// blockNumber.
	QueryBlock(ctx context.Context, blockNumber uint64, config ...Config) (Block, error)
}

type standardConfig struct {
	fn func(*RequestOptions)
}

// Fn implements Config.
func (s *standardConfig) Fn(r *RequestOptions) {
	s.fn(r)
}

// Opt creates a standard configuration option.
func Opt(fn func(r *RequestOptions)) Config {
	return &standardConfig{fn}
}

// Config is a type for a function that can mutate a types.RequestOptions
// object.
type Config interface {
	Fn(*RequestOptions)
}

func ApplyConfigs(log *logrus.Logger, configs ...Config) *RequestOptions {
	uuid, err := uuid.NewRandom()
	if err != nil {
		panic(fmt.Errorf("uuid: %w", err))
	}

	opt := &RequestOptions{
		Log:       log,
		LogFields: make(logrus.Fields),
		Headers:   make(map[string]string),
		ID:        uuid.String(),
		Transient: make(map[string][]byte),
	}

	for _, config := range configs {
		config.Fn(opt)
	}

	return opt
}

// RequestOptions are operated on by the Config functions generated by
// the With* functions. There is no need for a consumer of this
// library to directly manipulate objects of this type.
type RequestOptions struct {
	HTTPClient          *http.Client
	Log                 *logrus.Logger
	LogFields           logrus.Fields
	Headers             map[string]string
	Endpoint            string
	ID                  string
	AuthToken           string
	Params              interface{}
	Transient           map[string][]byte
	Target              *interface{}
	TimestampGenerator  func(context.Context) string
	MspFilter           []string
	MinEndorsers        int
	Creator             string
	DependentTxID       string
	DisableWritePolling bool
	CcFetchURLDowngrade bool
	CcFetchURLProxy     *url.URL
	DependentBlock      string
	PhylumVersion       string
	NewPhylumVersion    string
}

// ShiroResponse is a wrapper for a response from a shiro
// chaincode. Even if the chaincode was invoked successfully, it may
// have signaled an error.
type ShiroResponse interface {
	UnmarshalTo(dst interface{}) error
	ResultJSON() []byte
	TransactionID() string
	Error() Error
}

// Error is a generic application error.
type Error interface {
	error

	// Code returns a numeric code categorizing the error.
	Code() int

	// Message returns a generic error message that corresponds to the
	// error Code.
	Message() string

	// DataJSON returns JSON data returned by the application with the
	// error, if any was provided. The slice returned by DataJSON will
	// either be empty or it will contain valid serialized JSON data.
	DataJSON() []byte
}

func NewFailureResponse(code int, message string, data []byte) *failureResponse {
	return &failureResponse{
		err: failureError{
			code: code, message: message, data: data},
	}
}

var _ ShiroResponse = (*failureResponse)(nil)

type failureError struct {
	code    int
	message string
	data    []byte
}

func (s *failureError) Code() int {
	return s.code
}

func (s *failureError) Message() string {
	return s.message
}

func (s *failureError) DataJSON() []byte {
	out := make([]byte, len(s.data))
	copy(out, s.data)
	return out
}

func (s *failureError) Error() string {
	return fmt.Sprintf("error [%d] message [%s]", s.Code(), s.Message())
}

type failureResponse struct {
	err failureError
}

func (s *failureResponse) UnmarshalTo(dst interface{}) error {
	return errors.New("can't unmarshal the result if the RPC call failed")
}

func (s *failureResponse) ResultJSON() []byte {
	return nil
}

func (s *failureResponse) TransactionID() string {
	return ""
}

func (s *failureResponse) Error() Error {
	return &s.err
}

var _ ShiroResponse = (*successResponse)(nil)

type successResponse struct {
	result []byte
	txID   string
}

func NewSuccessResponse(result []byte, txID string) *successResponse {
	return &successResponse{result: result, txID: txID}
}

func (s *successResponse) UnmarshalTo(dst interface{}) error {
	return UnmarshalProto(s.result, dst)
}

func (s *successResponse) ResultJSON() []byte {
	out := make([]byte, len(s.result))
	copy(out, s.result)
	return out
}

func (s *successResponse) TransactionID() string {
	return s.txID
}

func (s *successResponse) Error() Error {
	return nil
}

// Transaction is a wrapper for summary information about a transaction.
type Transaction interface {
	ID() string
	Reason() string
	Event() []byte
	ChaincodeID() string
}

var _ Transaction = &transaction{}

func NewTransaction(id string, reason string, event []byte, ccID string) *transaction {
	return &transaction{id: id, reason: reason, event: event, ccID: ccID}
}

type transaction struct {
	id     string
	reason string
	event  []byte
	ccID   string
}

func (t *transaction) ID() string {
	return t.id
}

func (t *transaction) Reason() string {
	return t.reason
}

func (t *transaction) Event() []byte {
	return t.event
}

func (t *transaction) ChaincodeID() string {
	return t.ccID
}

// Block is a wrapper for summary information about a block.
type Block interface {
	Hash() string
	Transactions() []Transaction
}

var _ Block = &block{}

func NewBlock(hash string, txs []Transaction) *block {
	return &block{hash: hash, transactions: txs}
}

type block struct {
	hash         string
	transactions []Transaction
}

func (b *block) Hash() string {
	return b.hash
}

func (b *block) Transactions() []Transaction {
	out := make([]Transaction, len(b.transactions))
	copy(out, b.transactions)
	return out
}

// UnmarshalProto attempts to unmarshal protobuf bytes with backwards compatability.
func UnmarshalProto(src []byte, dst interface{}) error {
	var err error
	switch message := dst.(type) {
	case proto.Message:
		err = protojson.Unmarshal(src, message)
	case protoiface.MessageV1:
		//nolint:staticcheck // Deprecated Unmarshal used for backwards compatibility
		err = jsonpb.Unmarshal(bytes.NewReader(src), message)
	default:
		err = json.Unmarshal(src, message)
	}
	if err != nil {
		return err
	}

	return nil
}
